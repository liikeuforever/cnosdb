// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod models {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_FIELD_TYPE: i32 = -1;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_FIELD_TYPE: i32 = 4;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_FIELD_TYPE: [FieldType; 6] = [
        FieldType::Unknown,
        FieldType::Float,
        FieldType::Integer,
        FieldType::Unsigned,
        FieldType::Boolean,
        FieldType::String,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct FieldType(pub i32);
    #[allow(non_upper_case_globals)]
    impl FieldType {
        pub const Unknown: Self = Self(-1);
        pub const Float: Self = Self(0);
        pub const Integer: Self = Self(1);
        pub const Unsigned: Self = Self(2);
        pub const Boolean: Self = Self(3);
        pub const String: Self = Self(4);

        pub const ENUM_MIN: i32 = -1;
        pub const ENUM_MAX: i32 = 4;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::Unknown,
            Self::Float,
            Self::Integer,
            Self::Unsigned,
            Self::Boolean,
            Self::String,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::Unknown => Some("Unknown"),
                Self::Float => Some("Float"),
                Self::Integer => Some("Integer"),
                Self::Unsigned => Some("Unsigned"),
                Self::Boolean => Some("Boolean"),
                Self::String => Some("String"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for FieldType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for FieldType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for FieldType {
        type Output = FieldType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for FieldType {
        type Scalar = i32;
        #[inline]
        fn to_little_endian(self) -> i32 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i32) -> Self {
            let b = i32::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for FieldType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i32::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for FieldType {}
    pub enum PingBodyOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PingBody<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PingBody<'a> {
        type Inner = PingBody<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> PingBody<'a> {
        pub const VT_PAYLOAD: flatbuffers::VOffsetT = 4;

        pub const fn get_fully_qualified_name() -> &'static str {
            "models.PingBody"
        }

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PingBody { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PingBodyArgs<'args>,
        ) -> flatbuffers::WIPOffset<PingBody<'bldr>> {
            let mut builder = PingBodyBuilder::new(_fbb);
            if let Some(x) = args.payload {
                builder.add_payload(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn payload(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        PingBody::VT_PAYLOAD,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for PingBody<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "payload",
                    Self::VT_PAYLOAD,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct PingBodyArgs<'a> {
        pub payload: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for PingBodyArgs<'a> {
        #[inline]
        fn default() -> Self {
            PingBodyArgs { payload: None }
        }
    }

    pub struct PingBodyBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PingBodyBuilder<'a, 'b> {
        #[inline]
        pub fn add_payload(
            &mut self,
            payload: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PingBody::VT_PAYLOAD, payload);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PingBodyBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PingBodyBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PingBody<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for PingBody<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("PingBody");
            ds.field("payload", &self.payload());
            ds.finish()
        }
    }
    pub enum TagOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Tag<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Tag<'a> {
        type Inner = Tag<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Tag<'a> {
        pub const VT_VALUE: flatbuffers::VOffsetT = 4;

        pub const fn get_fully_qualified_name() -> &'static str {
            "models.Tag"
        }

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Tag { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TagArgs<'args>,
        ) -> flatbuffers::WIPOffset<Tag<'bldr>> {
            let mut builder = TagBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn value(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        Tag::VT_VALUE,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for Tag<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "value",
                    Self::VT_VALUE,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct TagArgs<'a> {
        pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for TagArgs<'a> {
        #[inline]
        fn default() -> Self {
            TagArgs { value: None }
        }
    }

    pub struct TagBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TagBuilder<'a, 'b> {
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Tag::VT_VALUE, value);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TagBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TagBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Tag<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Tag<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Tag");
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum FieldOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Field<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Field<'a> {
        type Inner = Field<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Field<'a> {
        pub const VT_VALUE: flatbuffers::VOffsetT = 4;

        pub const fn get_fully_qualified_name() -> &'static str {
            "models.Field"
        }

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Field { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FieldArgs<'args>,
        ) -> flatbuffers::WIPOffset<Field<'bldr>> {
            let mut builder = FieldBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn value(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        Field::VT_VALUE,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for Field<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "value",
                    Self::VT_VALUE,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct FieldArgs<'a> {
        pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for FieldArgs<'a> {
        #[inline]
        fn default() -> Self {
            FieldArgs { value: None }
        }
    }

    pub struct FieldBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FieldBuilder<'a, 'b> {
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Field::VT_VALUE, value);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FieldBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FieldBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Field<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Field<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Field");
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum SchemaOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Schema<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Schema<'a> {
        type Inner = Schema<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Schema<'a> {
        pub const VT_TAG_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_FIELD_NAME: flatbuffers::VOffsetT = 6;
        pub const VT_FIELD_TYPE: flatbuffers::VOffsetT = 8;

        pub const fn get_fully_qualified_name() -> &'static str {
            "models.Schema"
        }

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Schema { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SchemaArgs<'args>,
        ) -> flatbuffers::WIPOffset<Schema<'bldr>> {
            let mut builder = SchemaBuilder::new(_fbb);
            if let Some(x) = args.field_type {
                builder.add_field_type(x);
            }
            if let Some(x) = args.field_name {
                builder.add_field_name(x);
            }
            if let Some(x) = args.tag_name {
                builder.add_tag_name(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn tag_name(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(Schema::VT_TAG_NAME, None)
            }
        }
        #[inline]
        pub fn field_name(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(Schema::VT_FIELD_NAME, None)
            }
        }
        #[inline]
        pub fn field_type(&self) -> Option<flatbuffers::Vector<'a, FieldType>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, FieldType>>>(
                        Schema::VT_FIELD_TYPE,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for Schema<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                >>("tag_name", Self::VT_TAG_NAME, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                >>("field_name", Self::VT_FIELD_NAME, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, FieldType>>>(
                    "field_type",
                    Self::VT_FIELD_TYPE,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct SchemaArgs<'a> {
        pub tag_name: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
        pub field_name: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
        pub field_type: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, FieldType>>>,
    }
    impl<'a> Default for SchemaArgs<'a> {
        #[inline]
        fn default() -> Self {
            SchemaArgs {
                tag_name: None,
                field_name: None,
                field_type: None,
            }
        }
    }

    pub struct SchemaBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SchemaBuilder<'a, 'b> {
        #[inline]
        pub fn add_tag_name(
            &mut self,
            tag_name: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Schema::VT_TAG_NAME, tag_name);
        }
        #[inline]
        pub fn add_field_name(
            &mut self,
            field_name: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Schema::VT_FIELD_NAME, field_name);
        }
        #[inline]
        pub fn add_field_type(
            &mut self,
            field_type: flatbuffers::WIPOffset<flatbuffers::Vector<'b, FieldType>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Schema::VT_FIELD_TYPE, field_type);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SchemaBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SchemaBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Schema<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Schema<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Schema");
            ds.field("tag_name", &self.tag_name());
            ds.field("field_name", &self.field_name());
            ds.field("field_type", &self.field_type());
            ds.finish()
        }
    }
    pub enum PointOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Point<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Point<'a> {
        type Inner = Point<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Point<'a> {
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 4;
        pub const VT_TAGS: flatbuffers::VOffsetT = 6;
        pub const VT_TAGS_NULLBIT: flatbuffers::VOffsetT = 8;
        pub const VT_FIELDS: flatbuffers::VOffsetT = 10;
        pub const VT_FIELDS_NULLBIT: flatbuffers::VOffsetT = 12;

        pub const fn get_fully_qualified_name() -> &'static str {
            "models.Point"
        }

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Point { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PointArgs<'args>,
        ) -> flatbuffers::WIPOffset<Point<'bldr>> {
            let mut builder = PointBuilder::new(_fbb);
            builder.add_timestamp(args.timestamp);
            if let Some(x) = args.fields_nullbit {
                builder.add_fields_nullbit(x);
            }
            if let Some(x) = args.fields {
                builder.add_fields(x);
            }
            if let Some(x) = args.tags_nullbit {
                builder.add_tags_nullbit(x);
            }
            if let Some(x) = args.tags {
                builder.add_tags(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn timestamp(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<i64>(Point::VT_TIMESTAMP, Some(0)).unwrap() }
        }
        #[inline]
        pub fn tags(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tag<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tag>>,
                >>(Point::VT_TAGS, None)
            }
        }
        #[inline]
        pub fn tags_nullbit(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        Point::VT_TAGS_NULLBIT,
                        None,
                    )
            }
        }
        #[inline]
        pub fn fields(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Field<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Field>>,
                >>(Point::VT_FIELDS, None)
            }
        }
        #[inline]
        pub fn fields_nullbit(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        Point::VT_FIELDS_NULLBIT,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for Point<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i64>("timestamp", Self::VT_TIMESTAMP, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Tag>>,
                >>("tags", Self::VT_TAGS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "tags_nullbit",
                    Self::VT_TAGS_NULLBIT,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Field>>,
                >>("fields", Self::VT_FIELDS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "fields_nullbit",
                    Self::VT_FIELDS_NULLBIT,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct PointArgs<'a> {
        pub timestamp: i64,
        pub tags: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tag<'a>>>>,
        >,
        pub tags_nullbit: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub fields: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Field<'a>>>,
            >,
        >,
        pub fields_nullbit: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for PointArgs<'a> {
        #[inline]
        fn default() -> Self {
            PointArgs {
                timestamp: 0,
                tags: None,
                tags_nullbit: None,
                fields: None,
                fields_nullbit: None,
            }
        }
    }

    pub struct PointBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PointBuilder<'a, 'b> {
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: i64) {
            self.fbb_
                .push_slot::<i64>(Point::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_tags(
            &mut self,
            tags: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Tag<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Point::VT_TAGS, tags);
        }
        #[inline]
        pub fn add_tags_nullbit(
            &mut self,
            tags_nullbit: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Point::VT_TAGS_NULLBIT,
                tags_nullbit,
            );
        }
        #[inline]
        pub fn add_fields(
            &mut self,
            fields: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Field<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Point::VT_FIELDS, fields);
        }
        #[inline]
        pub fn add_fields_nullbit(
            &mut self,
            fields_nullbit: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Point::VT_FIELDS_NULLBIT,
                fields_nullbit,
            );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PointBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PointBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Point<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Point<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Point");
            ds.field("timestamp", &self.timestamp());
            ds.field("tags", &self.tags());
            ds.field("tags_nullbit", &self.tags_nullbit());
            ds.field("fields", &self.fields());
            ds.field("fields_nullbit", &self.fields_nullbit());
            ds.finish()
        }
    }
    pub enum TableOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Table<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Table<'a> {
        type Inner = Table<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Table<'a> {
        pub const VT_TAB: flatbuffers::VOffsetT = 4;
        pub const VT_SCHEMA: flatbuffers::VOffsetT = 6;
        pub const VT_POINTS: flatbuffers::VOffsetT = 8;
        pub const VT_NUM_ROWS: flatbuffers::VOffsetT = 10;

        pub const fn get_fully_qualified_name() -> &'static str {
            "models.Table"
        }

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Table { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TableArgs<'args>,
        ) -> flatbuffers::WIPOffset<Table<'bldr>> {
            let mut builder = TableBuilder::new(_fbb);
            builder.add_num_rows(args.num_rows);
            if let Some(x) = args.points {
                builder.add_points(x);
            }
            if let Some(x) = args.schema {
                builder.add_schema(x);
            }
            if let Some(x) = args.tab {
                builder.add_tab(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn tab(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        Table::VT_TAB,
                        None,
                    )
            }
        }
        #[inline]
        pub fn schema(&self) -> Option<Schema<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Schema>>(Table::VT_SCHEMA, None)
            }
        }
        #[inline]
        pub fn points(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Point<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Point>>,
                >>(Table::VT_POINTS, None)
            }
        }
        #[inline]
        pub fn num_rows(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(Table::VT_NUM_ROWS, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for Table<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "tab",
                    Self::VT_TAB,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Schema>>(
                    "schema",
                    Self::VT_SCHEMA,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Point>>,
                >>("points", Self::VT_POINTS, false)?
                .visit_field::<u64>("num_rows", Self::VT_NUM_ROWS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TableArgs<'a> {
        pub tab: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub schema: Option<flatbuffers::WIPOffset<Schema<'a>>>,
        pub points: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Point<'a>>>,
            >,
        >,
        pub num_rows: u64,
    }
    impl<'a> Default for TableArgs<'a> {
        #[inline]
        fn default() -> Self {
            TableArgs {
                tab: None,
                schema: None,
                points: None,
                num_rows: 0,
            }
        }
    }

    pub struct TableBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TableBuilder<'a, 'b> {
        #[inline]
        pub fn add_tab(&mut self, tab: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Table::VT_TAB, tab);
        }
        #[inline]
        pub fn add_schema(&mut self, schema: flatbuffers::WIPOffset<Schema<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Schema>>(Table::VT_SCHEMA, schema);
        }
        #[inline]
        pub fn add_points(
            &mut self,
            points: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Point<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Table::VT_POINTS, points);
        }
        #[inline]
        pub fn add_num_rows(&mut self, num_rows: u64) {
            self.fbb_.push_slot::<u64>(Table::VT_NUM_ROWS, num_rows, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TableBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TableBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Table<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Table<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Table");
            ds.field("tab", &self.tab());
            ds.field("schema", &self.schema());
            ds.field("points", &self.points());
            ds.field("num_rows", &self.num_rows());
            ds.finish()
        }
    }
    pub enum PointsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Points<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Points<'a> {
        type Inner = Points<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Points<'a> {
        pub const VT_DB: flatbuffers::VOffsetT = 4;
        pub const VT_TABLES: flatbuffers::VOffsetT = 6;

        pub const fn get_fully_qualified_name() -> &'static str {
            "models.Points"
        }

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Points { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PointsArgs<'args>,
        ) -> flatbuffers::WIPOffset<Points<'bldr>> {
            let mut builder = PointsBuilder::new(_fbb);
            if let Some(x) = args.tables {
                builder.add_tables(x);
            }
            if let Some(x) = args.db {
                builder.add_db(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn db(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        Points::VT_DB,
                        None,
                    )
            }
        }
        #[inline]
        pub fn tables(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Table<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Table>>,
                >>(Points::VT_TABLES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for Points<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "db",
                    Self::VT_DB,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Table>>,
                >>("tables", Self::VT_TABLES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct PointsArgs<'a> {
        pub db: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub tables: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Table<'a>>>,
            >,
        >,
    }
    impl<'a> Default for PointsArgs<'a> {
        #[inline]
        fn default() -> Self {
            PointsArgs {
                db: None,
                tables: None,
            }
        }
    }

    pub struct PointsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PointsBuilder<'a, 'b> {
        #[inline]
        pub fn add_db(&mut self, db: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Points::VT_DB, db);
        }
        #[inline]
        pub fn add_tables(
            &mut self,
            tables: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Table<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Points::VT_TABLES, tables);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PointsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PointsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Points<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Points<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Points");
            ds.field("db", &self.db());
            ds.field("tables", &self.tables());
            ds.finish()
        }
    }
} // pub mod models
