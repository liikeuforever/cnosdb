// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod models {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_FIELD_TYPE: i32 = -1;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_FIELD_TYPE: i32 = 4;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_FIELD_TYPE: [FieldType; 6] = [
        FieldType::Unknown,
        FieldType::Float,
        FieldType::Integer,
        FieldType::Unsigned,
        FieldType::Boolean,
        FieldType::String,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct FieldType(pub i32);
    #[allow(non_upper_case_globals)]
    impl FieldType {
        pub const Unknown: Self = Self(-1);
        pub const Float: Self = Self(0);
        pub const Integer: Self = Self(1);
        pub const Unsigned: Self = Self(2);
        pub const Boolean: Self = Self(3);
        pub const String: Self = Self(4);

        pub const ENUM_MIN: i32 = -1;
        pub const ENUM_MAX: i32 = 4;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::Unknown,
            Self::Float,
            Self::Integer,
            Self::Unsigned,
            Self::Boolean,
            Self::String,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::Unknown => Some("Unknown"),
                Self::Float => Some("Float"),
                Self::Integer => Some("Integer"),
                Self::Unsigned => Some("Unsigned"),
                Self::Boolean => Some("Boolean"),
                Self::String => Some("String"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for FieldType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for FieldType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for FieldType {
        type Output = FieldType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for FieldType {
        type Scalar = i32;
        #[inline]
        fn to_little_endian(self) -> i32 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i32) -> Self {
            let b = i32::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for FieldType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i32::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for FieldType {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_COLUMN_TYPE: i32 = -1;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_COLUMN_TYPE: i32 = 2;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_COLUMN_TYPE: [ColumnType; 4] = [
        ColumnType::Unknown,
        ColumnType::Time,
        ColumnType::Tag,
        ColumnType::Field,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct ColumnType(pub i32);
    #[allow(non_upper_case_globals)]
    impl ColumnType {
        pub const Unknown: Self = Self(-1);
        pub const Time: Self = Self(0);
        pub const Tag: Self = Self(1);
        pub const Field: Self = Self(2);

        pub const ENUM_MIN: i32 = -1;
        pub const ENUM_MAX: i32 = 2;
        pub const ENUM_VALUES: &'static [Self] =
            &[Self::Unknown, Self::Time, Self::Tag, Self::Field];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::Unknown => Some("Unknown"),
                Self::Time => Some("Time"),
                Self::Tag => Some("Tag"),
                Self::Field => Some("Field"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for ColumnType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for ColumnType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for ColumnType {
        type Output = ColumnType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for ColumnType {
        type Scalar = i32;
        #[inline]
        fn to_little_endian(self) -> i32 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i32) -> Self {
            let b = i32::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for ColumnType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i32::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ColumnType {}
    pub enum PingBodyOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PingBody<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PingBody<'a> {
        type Inner = PingBody<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> PingBody<'a> {
        pub const VT_PAYLOAD: flatbuffers::VOffsetT = 4;

        pub const fn get_fully_qualified_name() -> &'static str {
            "models.PingBody"
        }

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PingBody { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PingBodyArgs<'args>,
        ) -> flatbuffers::WIPOffset<PingBody<'bldr>> {
            let mut builder = PingBodyBuilder::new(_fbb);
            if let Some(x) = args.payload {
                builder.add_payload(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn payload(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        PingBody::VT_PAYLOAD,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for PingBody<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "payload",
                    Self::VT_PAYLOAD,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct PingBodyArgs<'a> {
        pub payload: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for PingBodyArgs<'a> {
        #[inline]
        fn default() -> Self {
            PingBodyArgs { payload: None }
        }
    }

    pub struct PingBodyBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PingBodyBuilder<'a, 'b> {
        #[inline]
        pub fn add_payload(
            &mut self,
            payload: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PingBody::VT_PAYLOAD, payload);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PingBodyBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PingBodyBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PingBody<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for PingBody<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("PingBody");
            ds.field("payload", &self.payload());
            ds.finish()
        }
    }
    pub enum ValuesOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Values<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Values<'a> {
        type Inner = Values<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Values<'a> {
        pub const VT_FLOAT_VALUE: flatbuffers::VOffsetT = 4;
        pub const VT_INT_VALUE: flatbuffers::VOffsetT = 6;
        pub const VT_UINT_VALUE: flatbuffers::VOffsetT = 8;
        pub const VT_BOOL_VALUE: flatbuffers::VOffsetT = 10;
        pub const VT_STRING_VALUE: flatbuffers::VOffsetT = 12;

        pub const fn get_fully_qualified_name() -> &'static str {
            "models.Values"
        }

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Values { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ValuesArgs<'args>,
        ) -> flatbuffers::WIPOffset<Values<'bldr>> {
            let mut builder = ValuesBuilder::new(_fbb);
            if let Some(x) = args.string_value {
                builder.add_string_value(x);
            }
            if let Some(x) = args.bool_value {
                builder.add_bool_value(x);
            }
            if let Some(x) = args.uint_value {
                builder.add_uint_value(x);
            }
            if let Some(x) = args.int_value {
                builder.add_int_value(x);
            }
            if let Some(x) = args.float_value {
                builder.add_float_value(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn float_value(&self) -> Option<flatbuffers::Vector<'a, f64>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(
                        Values::VT_FLOAT_VALUE,
                        None,
                    )
            }
        }
        #[inline]
        pub fn int_value(&self) -> Option<flatbuffers::Vector<'a, i64>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(
                        Values::VT_INT_VALUE,
                        None,
                    )
            }
        }
        #[inline]
        pub fn uint_value(&self) -> Option<flatbuffers::Vector<'a, u64>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(
                        Values::VT_UINT_VALUE,
                        None,
                    )
            }
        }
        #[inline]
        pub fn bool_value(&self) -> Option<flatbuffers::Vector<'a, bool>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, bool>>>(
                        Values::VT_BOOL_VALUE,
                        None,
                    )
            }
        }
        #[inline]
        pub fn string_value(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(Values::VT_STRING_VALUE, None)
            }
        }
    }

    impl flatbuffers::Verifiable for Values<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(
                    "float_value",
                    Self::VT_FLOAT_VALUE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>(
                    "int_value",
                    Self::VT_INT_VALUE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>(
                    "uint_value",
                    Self::VT_UINT_VALUE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, bool>>>(
                    "bool_value",
                    Self::VT_BOOL_VALUE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                >>("string_value", Self::VT_STRING_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ValuesArgs<'a> {
        pub float_value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
        pub int_value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
        pub uint_value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
        pub bool_value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, bool>>>,
        pub string_value: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
    }
    impl<'a> Default for ValuesArgs<'a> {
        #[inline]
        fn default() -> Self {
            ValuesArgs {
                float_value: None,
                int_value: None,
                uint_value: None,
                bool_value: None,
                string_value: None,
            }
        }
    }

    pub struct ValuesBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ValuesBuilder<'a, 'b> {
        #[inline]
        pub fn add_float_value(
            &mut self,
            float_value: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f64>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Values::VT_FLOAT_VALUE, float_value);
        }
        #[inline]
        pub fn add_int_value(
            &mut self,
            int_value: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i64>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Values::VT_INT_VALUE, int_value);
        }
        #[inline]
        pub fn add_uint_value(
            &mut self,
            uint_value: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u64>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Values::VT_UINT_VALUE, uint_value);
        }
        #[inline]
        pub fn add_bool_value(
            &mut self,
            bool_value: flatbuffers::WIPOffset<flatbuffers::Vector<'b, bool>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Values::VT_BOOL_VALUE, bool_value);
        }
        #[inline]
        pub fn add_string_value(
            &mut self,
            string_value: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Values::VT_STRING_VALUE,
                string_value,
            );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ValuesBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ValuesBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Values<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Values<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Values");
            ds.field("float_value", &self.float_value());
            ds.field("int_value", &self.int_value());
            ds.field("uint_value", &self.uint_value());
            ds.field("bool_value", &self.bool_value());
            ds.field("string_value", &self.string_value());
            ds.finish()
        }
    }
    pub enum ColumnOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Column<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Column<'a> {
        type Inner = Column<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Column<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_COLUMN_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_FIELD_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_COL_VALUES: flatbuffers::VOffsetT = 10;
        pub const VT_NULLBITS: flatbuffers::VOffsetT = 12;

        pub const fn get_fully_qualified_name() -> &'static str {
            "models.Column"
        }

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Column { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ColumnArgs<'args>,
        ) -> flatbuffers::WIPOffset<Column<'bldr>> {
            let mut builder = ColumnBuilder::new(_fbb);
            if let Some(x) = args.nullbits {
                builder.add_nullbits(x);
            }
            if let Some(x) = args.col_values {
                builder.add_col_values(x);
            }
            builder.add_field_type(args.field_type);
            builder.add_column_type(args.column_type);
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Column::VT_NAME, None)
            }
        }
        #[inline]
        pub fn column_type(&self) -> ColumnType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ColumnType>(Column::VT_COLUMN_TYPE, Some(ColumnType::Time))
                    .unwrap()
            }
        }
        #[inline]
        pub fn field_type(&self) -> FieldType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<FieldType>(Column::VT_FIELD_TYPE, Some(FieldType::Float))
                    .unwrap()
            }
        }
        #[inline]
        pub fn col_values(&self) -> Option<Values<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Values>>(Column::VT_COL_VALUES, None)
            }
        }
        #[inline]
        pub fn nullbits(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        Column::VT_NULLBITS,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for Column<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
                .visit_field::<ColumnType>("column_type", Self::VT_COLUMN_TYPE, false)?
                .visit_field::<FieldType>("field_type", Self::VT_FIELD_TYPE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<Values>>(
                    "col_values",
                    Self::VT_COL_VALUES,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "nullbits",
                    Self::VT_NULLBITS,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ColumnArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub column_type: ColumnType,
        pub field_type: FieldType,
        pub col_values: Option<flatbuffers::WIPOffset<Values<'a>>>,
        pub nullbits: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for ColumnArgs<'a> {
        #[inline]
        fn default() -> Self {
            ColumnArgs {
                name: None,
                column_type: ColumnType::Time,
                field_type: FieldType::Float,
                col_values: None,
                nullbits: None,
            }
        }
    }

    pub struct ColumnBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ColumnBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Column::VT_NAME, name);
        }
        #[inline]
        pub fn add_column_type(&mut self, column_type: ColumnType) {
            self.fbb_.push_slot::<ColumnType>(
                Column::VT_COLUMN_TYPE,
                column_type,
                ColumnType::Time,
            );
        }
        #[inline]
        pub fn add_field_type(&mut self, field_type: FieldType) {
            self.fbb_
                .push_slot::<FieldType>(Column::VT_FIELD_TYPE, field_type, FieldType::Float);
        }
        #[inline]
        pub fn add_col_values(&mut self, col_values: flatbuffers::WIPOffset<Values<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Values>>(
                    Column::VT_COL_VALUES,
                    col_values,
                );
        }
        #[inline]
        pub fn add_nullbits(
            &mut self,
            nullbits: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Column::VT_NULLBITS, nullbits);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ColumnBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ColumnBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Column<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Column<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Column");
            ds.field("name", &self.name());
            ds.field("column_type", &self.column_type());
            ds.field("field_type", &self.field_type());
            ds.field("col_values", &self.col_values());
            ds.field("nullbits", &self.nullbits());
            ds.finish()
        }
    }
    pub enum TableOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Table<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Table<'a> {
        type Inner = Table<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Table<'a> {
        pub const VT_TAB: flatbuffers::VOffsetT = 4;
        pub const VT_COLUMNS: flatbuffers::VOffsetT = 6;
        pub const VT_NUM_ROWS: flatbuffers::VOffsetT = 8;

        pub const fn get_fully_qualified_name() -> &'static str {
            "models.Table"
        }

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Table { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TableArgs<'args>,
        ) -> flatbuffers::WIPOffset<Table<'bldr>> {
            let mut builder = TableBuilder::new(_fbb);
            builder.add_num_rows(args.num_rows);
            if let Some(x) = args.columns {
                builder.add_columns(x);
            }
            if let Some(x) = args.tab {
                builder.add_tab(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn tab(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Table::VT_TAB, None)
            }
        }
        #[inline]
        pub fn columns(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column>>,
                >>(Table::VT_COLUMNS, None)
            }
        }
        #[inline]
        pub fn num_rows(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(Table::VT_NUM_ROWS, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for Table<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tab", Self::VT_TAB, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Column>>,
                >>("columns", Self::VT_COLUMNS, false)?
                .visit_field::<u64>("num_rows", Self::VT_NUM_ROWS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TableArgs<'a> {
        pub tab: Option<flatbuffers::WIPOffset<&'a str>>,
        pub columns: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column<'a>>>,
            >,
        >,
        pub num_rows: u64,
    }
    impl<'a> Default for TableArgs<'a> {
        #[inline]
        fn default() -> Self {
            TableArgs {
                tab: None,
                columns: None,
                num_rows: 0,
            }
        }
    }

    pub struct TableBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TableBuilder<'a, 'b> {
        #[inline]
        pub fn add_tab(&mut self, tab: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Table::VT_TAB, tab);
        }
        #[inline]
        pub fn add_columns(
            &mut self,
            columns: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Column<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Table::VT_COLUMNS, columns);
        }
        #[inline]
        pub fn add_num_rows(&mut self, num_rows: u64) {
            self.fbb_.push_slot::<u64>(Table::VT_NUM_ROWS, num_rows, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TableBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TableBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Table<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Table<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Table");
            ds.field("tab", &self.tab());
            ds.field("columns", &self.columns());
            ds.field("num_rows", &self.num_rows());
            ds.finish()
        }
    }
    pub enum PointsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Points<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Points<'a> {
        type Inner = Points<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Points<'a> {
        pub const VT_DB: flatbuffers::VOffsetT = 4;
        pub const VT_TABLES: flatbuffers::VOffsetT = 6;

        pub const fn get_fully_qualified_name() -> &'static str {
            "models.Points"
        }

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Points { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PointsArgs<'args>,
        ) -> flatbuffers::WIPOffset<Points<'bldr>> {
            let mut builder = PointsBuilder::new(_fbb);
            if let Some(x) = args.tables {
                builder.add_tables(x);
            }
            if let Some(x) = args.db {
                builder.add_db(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn db(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Points::VT_DB, None)
            }
        }
        #[inline]
        pub fn tables(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Table<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Table>>,
                >>(Points::VT_TABLES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for Points<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("db", Self::VT_DB, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Table>>,
                >>("tables", Self::VT_TABLES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct PointsArgs<'a> {
        pub db: Option<flatbuffers::WIPOffset<&'a str>>,
        pub tables: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Table<'a>>>,
            >,
        >,
    }
    impl<'a> Default for PointsArgs<'a> {
        #[inline]
        fn default() -> Self {
            PointsArgs {
                db: None,
                tables: None,
            }
        }
    }

    pub struct PointsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PointsBuilder<'a, 'b> {
        #[inline]
        pub fn add_db(&mut self, db: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Points::VT_DB, db);
        }
        #[inline]
        pub fn add_tables(
            &mut self,
            tables: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Table<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Points::VT_TABLES, tables);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PointsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PointsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Points<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Points<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Points");
            ds.field("db", &self.db());
            ds.field("tables", &self.tables());
            ds.finish()
        }
    }
} // pub mod models
